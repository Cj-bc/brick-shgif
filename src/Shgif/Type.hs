{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE OverloadedStrings #-}

module Shgif.Type (
    Format(..), Shgif(..)
    , shgifToCanvas, updateShgifNoLoop, updateShgif, updateShgifReversedNoLoop, updateShgifReversed, getShgif, getShgifs
    , updateShgifTo
    , fromCanvas
    , canvas, width, height
) where

import GHC.Generics (Generic)
import Control.Lens (makeLenses, (.~), (^.), (&), (+~), over, set)
import Control.Monad (when)
import Data.HashMap.Lazy ((!))
import qualified Data.Vector as V
import Data.Text (unpack)
import Data.Maybe (fromMaybe)
import Data.Either (isLeft)
import Data.Yaml (FromJSON(..), withObject, (.:), Object(..), withArray
                 , withText
                 , Parser(..), Value(..), ParseException
                 , decodeFileEither)
import Tart.Canvas (Canvas, canvasFromText, newCanvas, canvasSize, prettyPrintCanvas)
import Control.Arrow (second)

-- Config {{{
defaultTimeStampInterval = 100
--- }}}

-- | Format  of shgif file
--
-- Currently only Page is suported
--
-- TODO: Support other format
data Format = Page -- ^ list data as list of String
            | Plot -- ^ list data based on its coordinate
            deriving (Generic, Show)

type TimeStamp = (Int, [String])
type FileName = String

-- | The main datatype that holds Shgif data
data Shgif = Shgif { _title     :: String
                   , _author    :: String
                   , _format    :: Format
                   , _width     :: Int
                   , _height    :: Int
                   , _currentTick :: Int
                   , _shgifData :: [TimeStamp]  -- ^ [(Time, String to write)]
                   , _canvas :: Maybe Canvas    -- ^ the 'Tart.Canvas' which will be rendered
                    }

makeLenses ''Shgif

instance FromJSON Format


-- instance FromJSON Shgif {{{
instance FromJSON Shgif where
  parseJSON = withObject "Shgif" $ \v -> Shgif
        <$> v .: "title"
        <*> v .: "author"
        <*> v .: "format"
        <*> v .: "width"
        <*> v .: "height"
        <*> return 0
        <*> parseFrame (v ! "data")
        <*> return Nothing

parseFrame :: Value -> Parser [TimeStamp]
parseFrame = withArray "data" $ \a -> sequence $ V.toList $ V.map parseTimeStamp a


parseTimeStamp :: Value -> Parser TimeStamp
parseTimeStamp = withObject "Frame" $ \f -> timeStamp
                    <$> f .: "timestamp"
                    <*> parseContents (f ! "contents")
    where
        timeStamp :: Int -> [String] -> TimeStamp
        timeStamp time ds = (time, ds)

parseContents :: Value -> Parser [String]
parseContents = withText "Contents" (return . tail . lines . unpack)
-- }}}


-- | Convert 'Shgif' into 'Tart.Canvas' datatype
-- This function only determine which frame to render, and pass it to 'canvasFromText'
shgifToCanvas :: Shgif -> IO Canvas
shgifToCanvas (Shgif _ _ _ w h tick ds _) = canvasFromText $ unlines $ map (addWidthPadding w) $ addHeightPadding  h frame
    where
        currentFrame t = fromMaybe (currentFrame (t-1)) $ lookup t ds
        frame :: [String]
        frame = currentFrame tick

        addWidthPadding :: Int -> String -> String
        addWidthPadding _ [] = []
        addWidthPadding req_width x | length x < req_width = x ++ replicate (req_width - (length x)) ' '
                                    | otherwise            = x

        addHeightPadding :: Int -> [String] -> [String]
        addHeightPadding req_height xs | length xs < req_height = xs ++ replicate (req_height - length xs) ""
                                       | otherwise              = xs



-- | Add initialized 'Canvas'
--
-- Shgif object is generated by parsing yaml, which isn't in 'IO'.
-- So it can't execute 'newCanvas' to give Shgif canvas.
-- Instead, I give it canvas here.
addInitialCanvas :: Shgif -> IO Shgif
addInitialCanvas sgf = do
    newC <- newCanvas (sgf^.width, sgf^.height) -- XXXX: is it correct order? (width, height)
    newC' <- shgifToCanvas $ sgf&canvas.~(Just newC)
    return $ sgf&canvas.~(Just newC')


-- | Get 'Shgif' data from Yaml file
getShgif :: FileName -> IO (Either ParseException Shgif)
getShgif n = do
    sgf <- (decodeFileEither n :: IO (Either ParseException Shgif))
    case sgf of
      Left e -> return $ Left e
      Right shgif -> do
        sgf' <- addInitialCanvas shgif
        return $ Right sgf'


-- | Get list of 'Shgif's from list of Yaml file
getShgifs :: [FileName] -> IO (Either [ParseException] [Shgif])
getShgifs xs = do
  results <- sequence $ map getShgif xs :: IO [Either ParseException Shgif]
  if (containsLeft results)
    then return $ Left  $ caughtExceptions results
    else return $ Right $ map fromRight results
  where
    containsLeft rs     = True `elem` map isLeft rs
    fromLeft (Left e)   = e
    fromRight (Right a) = a
    caughtExceptions rs = map fromLeft $ filter isLeft rs


-- | Create 'Shgif' from 'Tart.Canvas.Canvas'es without any meta value
--
-- If you can implement meta values, use 'fromCanvasWithMeta' instead.
--
-- The first argument specify the tick for each frame.
--
-- If 'Nothing', use 'defaultTimeStampInterval'
fromCanvas :: Maybe [Int] -> [Canvas] -> Shgif
fromCanvas Nothing cs = fromCanvasWithMeta "" "" defaultTimestamps cs
    where
        defaultTimestamps = take (length cs) $ 0: interval defaultTimeStampInterval
        interval i = i: interval (2*i)
fromCanvas (Just ts)  cs = fromCanvasWithMeta "" "" ts cs


-- | Create 'Shgif' from 'Tart.Canvas.Canvas' with meta value
--
-- This only support 'Page' format, because 'Tart.Canvas.Canvas' is Bitmap image.
--
-- Make sure to __duplicate the last Canvas__ so that it'll show up for more than 1 tick.
--
-- (If you don't, The last frame only appear for 1 tick. In most case, it's the same as invisible)
fromCanvasWithMeta :: String -> String -> [Int] -> [Canvas] -> Shgif
fromCanvasWithMeta title author timestamps cs = Shgif title author Page w h 0 convertedData Nothing
  where
    (w, h) = foldr1 (\(x,y ) (x', y') -> (max x x', max y y')) whList
    whList = fmap (canvasSize) cs
    convertedData :: [TimeStamp]
    convertedData = zip timestamps $ fmap (lines . prettyPrintCanvas False . pure) cs
    -- convertedData = zip timestamps $ fmap (lines . prettyPrintCanvas False . pure) canvasWithLastFrame
    canvasWithLastFrame = cs ++ [last cs]


-- | Update 'Shgif''s internal tick state, which will affect frame rendering.
--
-- As 'updateShgif' has type `Shgif -> IO Shgif`, it can be called inside 'Brick.EventM' monad.
--
-- This function __won't loop__ gif.
--
-- Use this if you want to show animation only once.
updateShgifNoLoop :: Shgif -> IO Shgif
updateShgifNoLoop shgif@(Shgif t a f w h tick ds c) = do
    let updateTick | tick <= lastTimeStamp = over currentTick (+ 1)
                   | otherwise             = id

    newC <- shgifToCanvas $ updateTick shgif

    return $ set canvas (Just newC) $ updateTick shgif
    where
        lastTimeStamp = maximum $ map fst ds


-- | Update 'Shgif''s internal tick state, which will affect frame rendering.  
--
-- As 'updateShgif' has type `Shgif -> IO Shgif`, it can be called inside brick's 'Brick.EventM' monad.
--
-- This function reverse and __won't loop__ gif.
--
-- Use this if you want to show reversed animation for only once.
updateShgifReversedNoLoop :: Shgif -> IO Shgif
updateShgifReversedNoLoop shgif = do
    let updateTick | 0 < (shgif^.currentTick) = over currentTick (subtract 1)
                   | otherwise                = id
    newC <- shgifToCanvas $ updateTick shgif
    return $ set canvas (Just newC) $ updateTick shgif


-- | Update 'Shgif''s internal tick state, which will affect frame rendering.  
--
-- As 'updateShgif' has type `Shgif -> IO Shgif`, it can be called inside brick's 'Brick.EventM' monad.
--
-- This function reverse gif.
--
-- Use this if you want to show reversed animation.
updateShgifReversed :: Shgif -> IO Shgif
updateShgifReversed shgif = do
    let updateTick = set currentTick (repeat lastTimeStamp $ (shgif^.currentTick) - 1)
    newC <- shgifToCanvas $ updateTick shgif
    return $ set canvas (Just newC) $ updateTick shgif
    where
        lastTimeStamp = maximum $ map fst (shgif^.shgifData)
        -- https://docs.unity3d.com/ja/2019.2/ScriptReference/Mathf.Repeat.html
        repeat max val | val < 0   = max
                       | otherwise = val

-- | Update 'Shgif''s internal tick state, which will affect frame rendering.  
--
-- As 'updateShgif' has type `Shgif -> IO Shgif`, it can be called inside brick's 'Brick.EventM' monad.
--
updateShgif :: Shgif -> IO Shgif
updateShgif shgif = do
    let updateTick = set currentTick (repeat lastTimeStamp $ (shgif^.currentTick) + 1)
    newC <- shgifToCanvas $ updateTick shgif
    return $ set canvas (Just newC) $ updateTick shgif
    where
        lastTimeStamp = maximum $ map fst (shgif^.shgifData)
        -- https://docs.unity3d.com/ja/2019.2/ScriptReference/Mathf.Repeat.html
        repeat max val | max < val = 0
                       | otherwise = val


-- | Update 'Shgif''s internal tick state to make it closer to given tick
updateShgifTo :: Int -> Shgif -> IO Shgif
updateShgifTo tick shgif  = do
    let tickToAdd = case (shgif^.currentTick) `compare` tick of
                        LT -> 1
                        EQ -> 0
                        GT -> -1
    newC <- shgifToCanvas (shgif&currentTick+~tickToAdd)
    return $ set canvas (Just newC) $ over currentTick (+ tickToAdd) shgif
